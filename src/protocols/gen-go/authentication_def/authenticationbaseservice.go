// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package authentication_def

import (
	"bytes"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type AuthenticationBaseService interface {
	// Parameters:
	//  - LoginInfo
	Login(login_info *FormaxLoginInfo) (r *FormaxLoginResult_, err error)
	// Parameters:
	//  - SessionInfo
	Logout(session_info *SessionInfo) (r Errno, err error)
	// Parameters:
	//  - SessionInfo
	ValidateSession(session_info *SessionInfo) (r Errno, err error)
	// Parameters:
	//  - Uid
	QueryUserBasicInfoByUID(uid int64) (r *UserBasicInfo, err error)
	// Parameters:
	//  - Uids
	BatchQueryUserBasicInfo(uids []int64) (r []*UserBasicInfo, err error)
	// Parameters:
	//  - Uid
	QueryUserRegAffliatedInfoByUID(uid int64) (r *RegistrationAffliatedInfo, err error)
	// Parameters:
	//  - LoginInfo
	MT4Authentication(login_info *MT4LoginInfo) (r Errno, err error)
	// Parameters:
	//  - BindInfo
	MT4BindAccount(bind_info *MT4BindInfo) (r Errno, err error)
	// Parameters:
	//  - Uid
	MT4QueryBindInfo(uid int64) (r *MT4Info, err error)
	// Parameters:
	//  - LoginInfo
	ForbagAuthentication(login_info *ForbagLoginInfo) (r Errno, err error)
	// Parameters:
	//  - BindInfo
	ForbagBindAccount(bind_info *ForbagBindInfo) (r Errno, err error)
	// Parameters:
	//  - Uid
	ForbagQueryBrokerInfoByUID(uid int64) (r []*ForbagBrokerInfo, err error)
	// Parameters:
	//  - LoginInfo
	QuickFixAuthentication(login_info *QuickFixLoginInfo) (r Errno, err error)
	// Parameters:
	//  - BindInfo
	QuickFixBindAccount(bind_info *QuickFixBindInfo) (r Errno, err error)
	// Parameters:
	//  - LoginInfo
	P2PAuthenticationBy(login_info *P2PLoginInfo) (r Errno, err error)
	// Parameters:
	//  - BindInfo
	P2PBindAccount(bind_info *P2PBindInfo) (r Errno, err error)
	// Parameters:
	//  - Uid
	P2PQueryBindInfo(uid int64) (r *P2PInfo, err error)
	// Parameters:
	//  - Userinfo
	UpdateUserBasicInfo(userinfo *UserBasicInfo) (r Errno, err error)
	// Parameters:
	//  - Uid
	//  - Oldpasswd
	//  - Newpasswd_
	ResetUserPasswordByUID(uid int64, oldpasswd string, newpasswd string) (r Errno, err error)
	Ping() (r Errno, err error)
}

type AuthenticationBaseServiceClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewAuthenticationBaseServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *AuthenticationBaseServiceClient {
	return &AuthenticationBaseServiceClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewAuthenticationBaseServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *AuthenticationBaseServiceClient {
	return &AuthenticationBaseServiceClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Parameters:
//  - LoginInfo
func (p *AuthenticationBaseServiceClient) Login(login_info *FormaxLoginInfo) (r *FormaxLoginResult_, err error) {
	if err = p.sendLogin(login_info); err != nil {
		return
	}
	return p.recvLogin()
}

func (p *AuthenticationBaseServiceClient) sendLogin(login_info *FormaxLoginInfo) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("Login", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := LoginArgs{
		LoginInfo: login_info,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvLogin() (value *FormaxLoginResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error2 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error3 error
		error3, err = error2.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error3
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "Login failed: out of sequence response")
		return
	}
	result := LoginResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - SessionInfo
func (p *AuthenticationBaseServiceClient) Logout(session_info *SessionInfo) (r Errno, err error) {
	if err = p.sendLogout(session_info); err != nil {
		return
	}
	return p.recvLogout()
}

func (p *AuthenticationBaseServiceClient) sendLogout(session_info *SessionInfo) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("Logout", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := LogoutArgs{
		SessionInfo: session_info,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvLogout() (value Errno, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error4 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error5 error
		error5, err = error4.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error5
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "Logout failed: out of sequence response")
		return
	}
	result := LogoutResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - SessionInfo
func (p *AuthenticationBaseServiceClient) ValidateSession(session_info *SessionInfo) (r Errno, err error) {
	if err = p.sendValidateSession(session_info); err != nil {
		return
	}
	return p.recvValidateSession()
}

func (p *AuthenticationBaseServiceClient) sendValidateSession(session_info *SessionInfo) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("ValidateSession", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ValidateSessionArgs{
		SessionInfo: session_info,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvValidateSession() (value Errno, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error6 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error7 error
		error7, err = error6.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error7
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ValidateSession failed: out of sequence response")
		return
	}
	result := ValidateSessionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Uid
func (p *AuthenticationBaseServiceClient) QueryUserBasicInfoByUID(uid int64) (r *UserBasicInfo, err error) {
	if err = p.sendQueryUserBasicInfoByUID(uid); err != nil {
		return
	}
	return p.recvQueryUserBasicInfoByUID()
}

func (p *AuthenticationBaseServiceClient) sendQueryUserBasicInfoByUID(uid int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("QueryUserBasicInfoByUID", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := QueryUserBasicInfoByUIDArgs{
		Uid: uid,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvQueryUserBasicInfoByUID() (value *UserBasicInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error8 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error9 error
		error9, err = error8.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error9
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "QueryUserBasicInfoByUID failed: out of sequence response")
		return
	}
	result := QueryUserBasicInfoByUIDResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Uids
func (p *AuthenticationBaseServiceClient) BatchQueryUserBasicInfo(uids []int64) (r []*UserBasicInfo, err error) {
	if err = p.sendBatchQueryUserBasicInfo(uids); err != nil {
		return
	}
	return p.recvBatchQueryUserBasicInfo()
}

func (p *AuthenticationBaseServiceClient) sendBatchQueryUserBasicInfo(uids []int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("BatchQueryUserBasicInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := BatchQueryUserBasicInfoArgs{
		Uids: uids,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvBatchQueryUserBasicInfo() (value []*UserBasicInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error10 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error11 error
		error11, err = error10.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error11
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "BatchQueryUserBasicInfo failed: out of sequence response")
		return
	}
	result := BatchQueryUserBasicInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Uid
func (p *AuthenticationBaseServiceClient) QueryUserRegAffliatedInfoByUID(uid int64) (r *RegistrationAffliatedInfo, err error) {
	if err = p.sendQueryUserRegAffliatedInfoByUID(uid); err != nil {
		return
	}
	return p.recvQueryUserRegAffliatedInfoByUID()
}

func (p *AuthenticationBaseServiceClient) sendQueryUserRegAffliatedInfoByUID(uid int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("QueryUserRegAffliatedInfoByUID", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := QueryUserRegAffliatedInfoByUIDArgs{
		Uid: uid,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvQueryUserRegAffliatedInfoByUID() (value *RegistrationAffliatedInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error12 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error13 error
		error13, err = error12.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error13
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "QueryUserRegAffliatedInfoByUID failed: out of sequence response")
		return
	}
	result := QueryUserRegAffliatedInfoByUIDResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - LoginInfo
func (p *AuthenticationBaseServiceClient) MT4Authentication(login_info *MT4LoginInfo) (r Errno, err error) {
	if err = p.sendMT4Authentication(login_info); err != nil {
		return
	}
	return p.recvMT4Authentication()
}

func (p *AuthenticationBaseServiceClient) sendMT4Authentication(login_info *MT4LoginInfo) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("MT4Authentication", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := MT4AuthenticationArgs{
		LoginInfo: login_info,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvMT4Authentication() (value Errno, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error14 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error15 error
		error15, err = error14.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error15
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "MT4Authentication failed: out of sequence response")
		return
	}
	result := MT4AuthenticationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - BindInfo
func (p *AuthenticationBaseServiceClient) MT4BindAccount(bind_info *MT4BindInfo) (r Errno, err error) {
	if err = p.sendMT4BindAccount(bind_info); err != nil {
		return
	}
	return p.recvMT4BindAccount()
}

func (p *AuthenticationBaseServiceClient) sendMT4BindAccount(bind_info *MT4BindInfo) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("MT4BindAccount", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := MT4BindAccountArgs{
		BindInfo: bind_info,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvMT4BindAccount() (value Errno, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error16 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error17 error
		error17, err = error16.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error17
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "MT4BindAccount failed: out of sequence response")
		return
	}
	result := MT4BindAccountResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Uid
func (p *AuthenticationBaseServiceClient) MT4QueryBindInfo(uid int64) (r *MT4Info, err error) {
	if err = p.sendMT4QueryBindInfo(uid); err != nil {
		return
	}
	return p.recvMT4QueryBindInfo()
}

func (p *AuthenticationBaseServiceClient) sendMT4QueryBindInfo(uid int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("MT4QueryBindInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := MT4QueryBindInfoArgs{
		Uid: uid,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvMT4QueryBindInfo() (value *MT4Info, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error18 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error19 error
		error19, err = error18.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error19
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "MT4QueryBindInfo failed: out of sequence response")
		return
	}
	result := MT4QueryBindInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - LoginInfo
func (p *AuthenticationBaseServiceClient) ForbagAuthentication(login_info *ForbagLoginInfo) (r Errno, err error) {
	if err = p.sendForbagAuthentication(login_info); err != nil {
		return
	}
	return p.recvForbagAuthentication()
}

func (p *AuthenticationBaseServiceClient) sendForbagAuthentication(login_info *ForbagLoginInfo) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("ForbagAuthentication", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ForbagAuthenticationArgs{
		LoginInfo: login_info,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvForbagAuthentication() (value Errno, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error20 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error21 error
		error21, err = error20.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error21
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ForbagAuthentication failed: out of sequence response")
		return
	}
	result := ForbagAuthenticationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - BindInfo
func (p *AuthenticationBaseServiceClient) ForbagBindAccount(bind_info *ForbagBindInfo) (r Errno, err error) {
	if err = p.sendForbagBindAccount(bind_info); err != nil {
		return
	}
	return p.recvForbagBindAccount()
}

func (p *AuthenticationBaseServiceClient) sendForbagBindAccount(bind_info *ForbagBindInfo) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("ForbagBindAccount", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ForbagBindAccountArgs{
		BindInfo: bind_info,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvForbagBindAccount() (value Errno, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error22 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error23 error
		error23, err = error22.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error23
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ForbagBindAccount failed: out of sequence response")
		return
	}
	result := ForbagBindAccountResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Uid
func (p *AuthenticationBaseServiceClient) ForbagQueryBrokerInfoByUID(uid int64) (r []*ForbagBrokerInfo, err error) {
	if err = p.sendForbagQueryBrokerInfoByUID(uid); err != nil {
		return
	}
	return p.recvForbagQueryBrokerInfoByUID()
}

func (p *AuthenticationBaseServiceClient) sendForbagQueryBrokerInfoByUID(uid int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("ForbagQueryBrokerInfoByUID", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ForbagQueryBrokerInfoByUIDArgs{
		Uid: uid,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvForbagQueryBrokerInfoByUID() (value []*ForbagBrokerInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error24 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error25 error
		error25, err = error24.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error25
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ForbagQueryBrokerInfoByUID failed: out of sequence response")
		return
	}
	result := ForbagQueryBrokerInfoByUIDResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - LoginInfo
func (p *AuthenticationBaseServiceClient) QuickFixAuthentication(login_info *QuickFixLoginInfo) (r Errno, err error) {
	if err = p.sendQuickFixAuthentication(login_info); err != nil {
		return
	}
	return p.recvQuickFixAuthentication()
}

func (p *AuthenticationBaseServiceClient) sendQuickFixAuthentication(login_info *QuickFixLoginInfo) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("QuickFixAuthentication", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := QuickFixAuthenticationArgs{
		LoginInfo: login_info,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvQuickFixAuthentication() (value Errno, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error26 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error27 error
		error27, err = error26.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error27
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "QuickFixAuthentication failed: out of sequence response")
		return
	}
	result := QuickFixAuthenticationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - BindInfo
func (p *AuthenticationBaseServiceClient) QuickFixBindAccount(bind_info *QuickFixBindInfo) (r Errno, err error) {
	if err = p.sendQuickFixBindAccount(bind_info); err != nil {
		return
	}
	return p.recvQuickFixBindAccount()
}

func (p *AuthenticationBaseServiceClient) sendQuickFixBindAccount(bind_info *QuickFixBindInfo) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("QuickFixBindAccount", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := QuickFixBindAccountArgs{
		BindInfo: bind_info,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvQuickFixBindAccount() (value Errno, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error28 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error29 error
		error29, err = error28.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error29
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "QuickFixBindAccount failed: out of sequence response")
		return
	}
	result := QuickFixBindAccountResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - LoginInfo
func (p *AuthenticationBaseServiceClient) P2PAuthenticationBy(login_info *P2PLoginInfo) (r Errno, err error) {
	if err = p.sendP2PAuthenticationBy(login_info); err != nil {
		return
	}
	return p.recvP2PAuthenticationBy()
}

func (p *AuthenticationBaseServiceClient) sendP2PAuthenticationBy(login_info *P2PLoginInfo) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("P2PAuthenticationBy", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := P2PAuthenticationByArgs{
		LoginInfo: login_info,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvP2PAuthenticationBy() (value Errno, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error30 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error31 error
		error31, err = error30.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error31
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "P2PAuthenticationBy failed: out of sequence response")
		return
	}
	result := P2PAuthenticationByResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - BindInfo
func (p *AuthenticationBaseServiceClient) P2PBindAccount(bind_info *P2PBindInfo) (r Errno, err error) {
	if err = p.sendP2PBindAccount(bind_info); err != nil {
		return
	}
	return p.recvP2PBindAccount()
}

func (p *AuthenticationBaseServiceClient) sendP2PBindAccount(bind_info *P2PBindInfo) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("P2PBindAccount", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := P2PBindAccountArgs{
		BindInfo: bind_info,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvP2PBindAccount() (value Errno, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error32 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error33 error
		error33, err = error32.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error33
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "P2PBindAccount failed: out of sequence response")
		return
	}
	result := P2PBindAccountResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Uid
func (p *AuthenticationBaseServiceClient) P2PQueryBindInfo(uid int64) (r *P2PInfo, err error) {
	if err = p.sendP2PQueryBindInfo(uid); err != nil {
		return
	}
	return p.recvP2PQueryBindInfo()
}

func (p *AuthenticationBaseServiceClient) sendP2PQueryBindInfo(uid int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("P2PQueryBindInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := P2PQueryBindInfoArgs{
		Uid: uid,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvP2PQueryBindInfo() (value *P2PInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error34 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error35 error
		error35, err = error34.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error35
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "P2PQueryBindInfo failed: out of sequence response")
		return
	}
	result := P2PQueryBindInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Userinfo
func (p *AuthenticationBaseServiceClient) UpdateUserBasicInfo(userinfo *UserBasicInfo) (r Errno, err error) {
	if err = p.sendUpdateUserBasicInfo(userinfo); err != nil {
		return
	}
	return p.recvUpdateUserBasicInfo()
}

func (p *AuthenticationBaseServiceClient) sendUpdateUserBasicInfo(userinfo *UserBasicInfo) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("UpdateUserBasicInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UpdateUserBasicInfoArgs{
		Userinfo: userinfo,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvUpdateUserBasicInfo() (value Errno, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error36 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error37 error
		error37, err = error36.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error37
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "UpdateUserBasicInfo failed: out of sequence response")
		return
	}
	result := UpdateUserBasicInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Uid
//  - Oldpasswd
//  - Newpasswd_
func (p *AuthenticationBaseServiceClient) ResetUserPasswordByUID(uid int64, oldpasswd string, newpasswd string) (r Errno, err error) {
	if err = p.sendResetUserPasswordByUID(uid, oldpasswd, newpasswd); err != nil {
		return
	}
	return p.recvResetUserPasswordByUID()
}

func (p *AuthenticationBaseServiceClient) sendResetUserPasswordByUID(uid int64, oldpasswd string, newpasswd string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("ResetUserPasswordByUID", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ResetUserPasswordByUIDArgs{
		Uid:        uid,
		Oldpasswd:  oldpasswd,
		Newpasswd_: newpasswd,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvResetUserPasswordByUID() (value Errno, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error38 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error39 error
		error39, err = error38.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error39
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ResetUserPasswordByUID failed: out of sequence response")
		return
	}
	result := ResetUserPasswordByUIDResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

func (p *AuthenticationBaseServiceClient) Ping() (r Errno, err error) {
	if err = p.sendPing(); err != nil {
		return
	}
	return p.recvPing()
}

func (p *AuthenticationBaseServiceClient) sendPing() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("Ping", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := PingArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuthenticationBaseServiceClient) recvPing() (value Errno, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error40 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error41 error
		error41, err = error40.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error41
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "Ping failed: out of sequence response")
		return
	}
	result := PingResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

type AuthenticationBaseServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      AuthenticationBaseService
}

func (p *AuthenticationBaseServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *AuthenticationBaseServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *AuthenticationBaseServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewAuthenticationBaseServiceProcessor(handler AuthenticationBaseService) *AuthenticationBaseServiceProcessor {

	self42 := &AuthenticationBaseServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self42.processorMap["Login"] = &authenticationBaseServiceProcessorLogin{handler: handler}
	self42.processorMap["Logout"] = &authenticationBaseServiceProcessorLogout{handler: handler}
	self42.processorMap["ValidateSession"] = &authenticationBaseServiceProcessorValidateSession{handler: handler}
	self42.processorMap["QueryUserBasicInfoByUID"] = &authenticationBaseServiceProcessorQueryUserBasicInfoByUID{handler: handler}
	self42.processorMap["BatchQueryUserBasicInfo"] = &authenticationBaseServiceProcessorBatchQueryUserBasicInfo{handler: handler}
	self42.processorMap["QueryUserRegAffliatedInfoByUID"] = &authenticationBaseServiceProcessorQueryUserRegAffliatedInfoByUID{handler: handler}
	self42.processorMap["MT4Authentication"] = &authenticationBaseServiceProcessorMT4Authentication{handler: handler}
	self42.processorMap["MT4BindAccount"] = &authenticationBaseServiceProcessorMT4BindAccount{handler: handler}
	self42.processorMap["MT4QueryBindInfo"] = &authenticationBaseServiceProcessorMT4QueryBindInfo{handler: handler}
	self42.processorMap["ForbagAuthentication"] = &authenticationBaseServiceProcessorForbagAuthentication{handler: handler}
	self42.processorMap["ForbagBindAccount"] = &authenticationBaseServiceProcessorForbagBindAccount{handler: handler}
	self42.processorMap["ForbagQueryBrokerInfoByUID"] = &authenticationBaseServiceProcessorForbagQueryBrokerInfoByUID{handler: handler}
	self42.processorMap["QuickFixAuthentication"] = &authenticationBaseServiceProcessorQuickFixAuthentication{handler: handler}
	self42.processorMap["QuickFixBindAccount"] = &authenticationBaseServiceProcessorQuickFixBindAccount{handler: handler}
	self42.processorMap["P2PAuthenticationBy"] = &authenticationBaseServiceProcessorP2PAuthenticationBy{handler: handler}
	self42.processorMap["P2PBindAccount"] = &authenticationBaseServiceProcessorP2PBindAccount{handler: handler}
	self42.processorMap["P2PQueryBindInfo"] = &authenticationBaseServiceProcessorP2PQueryBindInfo{handler: handler}
	self42.processorMap["UpdateUserBasicInfo"] = &authenticationBaseServiceProcessorUpdateUserBasicInfo{handler: handler}
	self42.processorMap["ResetUserPasswordByUID"] = &authenticationBaseServiceProcessorResetUserPasswordByUID{handler: handler}
	self42.processorMap["Ping"] = &authenticationBaseServiceProcessorPing{handler: handler}
	return self42
}

func (p *AuthenticationBaseServiceProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x43 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x43.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x43

}

type authenticationBaseServiceProcessorLogin struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorLogin) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := LoginArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("Login", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := LoginResult{}
	var retval *FormaxLoginResult_
	var err2 error
	if retval, err2 = p.handler.Login(args.LoginInfo); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Login: "+err2.Error())
		oprot.WriteMessageBegin("Login", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("Login", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorLogout struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorLogout) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := LogoutArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("Logout", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := LogoutResult{}
	var retval Errno
	var err2 error
	if retval, err2 = p.handler.Logout(args.SessionInfo); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Logout: "+err2.Error())
		oprot.WriteMessageBegin("Logout", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("Logout", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorValidateSession struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorValidateSession) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ValidateSessionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("ValidateSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ValidateSessionResult{}
	var retval Errno
	var err2 error
	if retval, err2 = p.handler.ValidateSession(args.SessionInfo); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ValidateSession: "+err2.Error())
		oprot.WriteMessageBegin("ValidateSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("ValidateSession", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorQueryUserBasicInfoByUID struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorQueryUserBasicInfoByUID) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := QueryUserBasicInfoByUIDArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("QueryUserBasicInfoByUID", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := QueryUserBasicInfoByUIDResult{}
	var retval *UserBasicInfo
	var err2 error
	if retval, err2 = p.handler.QueryUserBasicInfoByUID(args.Uid); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing QueryUserBasicInfoByUID: "+err2.Error())
		oprot.WriteMessageBegin("QueryUserBasicInfoByUID", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("QueryUserBasicInfoByUID", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorBatchQueryUserBasicInfo struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorBatchQueryUserBasicInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := BatchQueryUserBasicInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("BatchQueryUserBasicInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := BatchQueryUserBasicInfoResult{}
	var retval []*UserBasicInfo
	var err2 error
	if retval, err2 = p.handler.BatchQueryUserBasicInfo(args.Uids); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing BatchQueryUserBasicInfo: "+err2.Error())
		oprot.WriteMessageBegin("BatchQueryUserBasicInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("BatchQueryUserBasicInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorQueryUserRegAffliatedInfoByUID struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorQueryUserRegAffliatedInfoByUID) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := QueryUserRegAffliatedInfoByUIDArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("QueryUserRegAffliatedInfoByUID", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := QueryUserRegAffliatedInfoByUIDResult{}
	var retval *RegistrationAffliatedInfo
	var err2 error
	if retval, err2 = p.handler.QueryUserRegAffliatedInfoByUID(args.Uid); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing QueryUserRegAffliatedInfoByUID: "+err2.Error())
		oprot.WriteMessageBegin("QueryUserRegAffliatedInfoByUID", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("QueryUserRegAffliatedInfoByUID", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorMT4Authentication struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorMT4Authentication) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := MT4AuthenticationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("MT4Authentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := MT4AuthenticationResult{}
	var retval Errno
	var err2 error
	if retval, err2 = p.handler.MT4Authentication(args.LoginInfo); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing MT4Authentication: "+err2.Error())
		oprot.WriteMessageBegin("MT4Authentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("MT4Authentication", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorMT4BindAccount struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorMT4BindAccount) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := MT4BindAccountArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("MT4BindAccount", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := MT4BindAccountResult{}
	var retval Errno
	var err2 error
	if retval, err2 = p.handler.MT4BindAccount(args.BindInfo); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing MT4BindAccount: "+err2.Error())
		oprot.WriteMessageBegin("MT4BindAccount", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("MT4BindAccount", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorMT4QueryBindInfo struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorMT4QueryBindInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := MT4QueryBindInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("MT4QueryBindInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := MT4QueryBindInfoResult{}
	var retval *MT4Info
	var err2 error
	if retval, err2 = p.handler.MT4QueryBindInfo(args.Uid); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing MT4QueryBindInfo: "+err2.Error())
		oprot.WriteMessageBegin("MT4QueryBindInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("MT4QueryBindInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorForbagAuthentication struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorForbagAuthentication) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ForbagAuthenticationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("ForbagAuthentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ForbagAuthenticationResult{}
	var retval Errno
	var err2 error
	if retval, err2 = p.handler.ForbagAuthentication(args.LoginInfo); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ForbagAuthentication: "+err2.Error())
		oprot.WriteMessageBegin("ForbagAuthentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("ForbagAuthentication", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorForbagBindAccount struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorForbagBindAccount) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ForbagBindAccountArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("ForbagBindAccount", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ForbagBindAccountResult{}
	var retval Errno
	var err2 error
	if retval, err2 = p.handler.ForbagBindAccount(args.BindInfo); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ForbagBindAccount: "+err2.Error())
		oprot.WriteMessageBegin("ForbagBindAccount", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("ForbagBindAccount", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorForbagQueryBrokerInfoByUID struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorForbagQueryBrokerInfoByUID) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ForbagQueryBrokerInfoByUIDArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("ForbagQueryBrokerInfoByUID", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ForbagQueryBrokerInfoByUIDResult{}
	var retval []*ForbagBrokerInfo
	var err2 error
	if retval, err2 = p.handler.ForbagQueryBrokerInfoByUID(args.Uid); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ForbagQueryBrokerInfoByUID: "+err2.Error())
		oprot.WriteMessageBegin("ForbagQueryBrokerInfoByUID", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("ForbagQueryBrokerInfoByUID", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorQuickFixAuthentication struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorQuickFixAuthentication) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := QuickFixAuthenticationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("QuickFixAuthentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := QuickFixAuthenticationResult{}
	var retval Errno
	var err2 error
	if retval, err2 = p.handler.QuickFixAuthentication(args.LoginInfo); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing QuickFixAuthentication: "+err2.Error())
		oprot.WriteMessageBegin("QuickFixAuthentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("QuickFixAuthentication", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorQuickFixBindAccount struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorQuickFixBindAccount) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := QuickFixBindAccountArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("QuickFixBindAccount", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := QuickFixBindAccountResult{}
	var retval Errno
	var err2 error
	if retval, err2 = p.handler.QuickFixBindAccount(args.BindInfo); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing QuickFixBindAccount: "+err2.Error())
		oprot.WriteMessageBegin("QuickFixBindAccount", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("QuickFixBindAccount", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorP2PAuthenticationBy struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorP2PAuthenticationBy) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := P2PAuthenticationByArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("P2PAuthenticationBy", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := P2PAuthenticationByResult{}
	var retval Errno
	var err2 error
	if retval, err2 = p.handler.P2PAuthenticationBy(args.LoginInfo); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing P2PAuthenticationBy: "+err2.Error())
		oprot.WriteMessageBegin("P2PAuthenticationBy", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("P2PAuthenticationBy", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorP2PBindAccount struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorP2PBindAccount) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := P2PBindAccountArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("P2PBindAccount", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := P2PBindAccountResult{}
	var retval Errno
	var err2 error
	if retval, err2 = p.handler.P2PBindAccount(args.BindInfo); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing P2PBindAccount: "+err2.Error())
		oprot.WriteMessageBegin("P2PBindAccount", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("P2PBindAccount", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorP2PQueryBindInfo struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorP2PQueryBindInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := P2PQueryBindInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("P2PQueryBindInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := P2PQueryBindInfoResult{}
	var retval *P2PInfo
	var err2 error
	if retval, err2 = p.handler.P2PQueryBindInfo(args.Uid); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing P2PQueryBindInfo: "+err2.Error())
		oprot.WriteMessageBegin("P2PQueryBindInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("P2PQueryBindInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorUpdateUserBasicInfo struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorUpdateUserBasicInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UpdateUserBasicInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("UpdateUserBasicInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UpdateUserBasicInfoResult{}
	var retval Errno
	var err2 error
	if retval, err2 = p.handler.UpdateUserBasicInfo(args.Userinfo); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing UpdateUserBasicInfo: "+err2.Error())
		oprot.WriteMessageBegin("UpdateUserBasicInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("UpdateUserBasicInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorResetUserPasswordByUID struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorResetUserPasswordByUID) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ResetUserPasswordByUIDArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("ResetUserPasswordByUID", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ResetUserPasswordByUIDResult{}
	var retval Errno
	var err2 error
	if retval, err2 = p.handler.ResetUserPasswordByUID(args.Uid, args.Oldpasswd, args.Newpasswd_); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ResetUserPasswordByUID: "+err2.Error())
		oprot.WriteMessageBegin("ResetUserPasswordByUID", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("ResetUserPasswordByUID", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type authenticationBaseServiceProcessorPing struct {
	handler AuthenticationBaseService
}

func (p *authenticationBaseServiceProcessorPing) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := PingArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("Ping", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := PingResult{}
	var retval Errno
	var err2 error
	if retval, err2 = p.handler.Ping(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Ping: "+err2.Error())
		oprot.WriteMessageBegin("Ping", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("Ping", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type LoginArgs struct {
	LoginInfo *FormaxLoginInfo `thrift:"login_info,1,required" json:"login_info"`
}

func NewLoginArgs() *LoginArgs {
	return &LoginArgs{}
}

var LoginArgs_LoginInfo_DEFAULT *FormaxLoginInfo

func (p *LoginArgs) GetLoginInfo() *FormaxLoginInfo {
	if !p.IsSetLoginInfo() {
		return LoginArgs_LoginInfo_DEFAULT
	}
	return p.LoginInfo
}
func (p *LoginArgs) IsSetLoginInfo() bool {
	return p.LoginInfo != nil
}

func (p *LoginArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LoginArgs) ReadField1(iprot thrift.TProtocol) error {
	p.LoginInfo = &FormaxLoginInfo{
		MUid: -1,
	}
	if err := p.LoginInfo.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.LoginInfo, err)
	}
	return nil
}

func (p *LoginArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Login_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LoginArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("login_info", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:login_info: %s", p, err)
	}
	if err := p.LoginInfo.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.LoginInfo, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:login_info: %s", p, err)
	}
	return err
}

func (p *LoginArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LoginArgs(%+v)", *p)
}

type LoginResult struct {
	Success *FormaxLoginResult_ `thrift:"success,0" json:"success"`
}

func NewLoginResult() *LoginResult {
	return &LoginResult{}
}

var LoginResult_Success_DEFAULT *FormaxLoginResult_

func (p *LoginResult) GetSuccess() *FormaxLoginResult_ {
	if !p.IsSetSuccess() {
		return LoginResult_Success_DEFAULT
	}
	return p.Success
}
func (p *LoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *LoginResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LoginResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &FormaxLoginResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *LoginResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Login_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LoginResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *LoginResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LoginResult(%+v)", *p)
}

type LogoutArgs struct {
	SessionInfo *SessionInfo `thrift:"session_info,1,required" json:"session_info"`
}

func NewLogoutArgs() *LogoutArgs {
	return &LogoutArgs{}
}

var LogoutArgs_SessionInfo_DEFAULT *SessionInfo

func (p *LogoutArgs) GetSessionInfo() *SessionInfo {
	if !p.IsSetSessionInfo() {
		return LogoutArgs_SessionInfo_DEFAULT
	}
	return p.SessionInfo
}
func (p *LogoutArgs) IsSetSessionInfo() bool {
	return p.SessionInfo != nil
}

func (p *LogoutArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LogoutArgs) ReadField1(iprot thrift.TProtocol) error {
	p.SessionInfo = &SessionInfo{
		MUid: -1,
	}
	if err := p.SessionInfo.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SessionInfo, err)
	}
	return nil
}

func (p *LogoutArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Logout_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LogoutArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("session_info", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:session_info: %s", p, err)
	}
	if err := p.SessionInfo.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.SessionInfo, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:session_info: %s", p, err)
	}
	return err
}

func (p *LogoutArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LogoutArgs(%+v)", *p)
}

type LogoutResult struct {
	Success *Errno `thrift:"success,0" json:"success"`
}

func NewLogoutResult() *LogoutResult {
	return &LogoutResult{}
}

var LogoutResult_Success_DEFAULT Errno

func (p *LogoutResult) GetSuccess() Errno {
	if !p.IsSetSuccess() {
		return LogoutResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *LogoutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *LogoutResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LogoutResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Errno(v)
		p.Success = &temp
	}
	return nil
}

func (p *LogoutResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Logout_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LogoutResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *LogoutResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LogoutResult(%+v)", *p)
}

type ValidateSessionArgs struct {
	SessionInfo *SessionInfo `thrift:"session_info,1,required" json:"session_info"`
}

func NewValidateSessionArgs() *ValidateSessionArgs {
	return &ValidateSessionArgs{}
}

var ValidateSessionArgs_SessionInfo_DEFAULT *SessionInfo

func (p *ValidateSessionArgs) GetSessionInfo() *SessionInfo {
	if !p.IsSetSessionInfo() {
		return ValidateSessionArgs_SessionInfo_DEFAULT
	}
	return p.SessionInfo
}
func (p *ValidateSessionArgs) IsSetSessionInfo() bool {
	return p.SessionInfo != nil
}

func (p *ValidateSessionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ValidateSessionArgs) ReadField1(iprot thrift.TProtocol) error {
	p.SessionInfo = &SessionInfo{
		MUid: -1,
	}
	if err := p.SessionInfo.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SessionInfo, err)
	}
	return nil
}

func (p *ValidateSessionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ValidateSession_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ValidateSessionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("session_info", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:session_info: %s", p, err)
	}
	if err := p.SessionInfo.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.SessionInfo, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:session_info: %s", p, err)
	}
	return err
}

func (p *ValidateSessionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ValidateSessionArgs(%+v)", *p)
}

type ValidateSessionResult struct {
	Success *Errno `thrift:"success,0" json:"success"`
}

func NewValidateSessionResult() *ValidateSessionResult {
	return &ValidateSessionResult{}
}

var ValidateSessionResult_Success_DEFAULT Errno

func (p *ValidateSessionResult) GetSuccess() Errno {
	if !p.IsSetSuccess() {
		return ValidateSessionResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *ValidateSessionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ValidateSessionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ValidateSessionResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Errno(v)
		p.Success = &temp
	}
	return nil
}

func (p *ValidateSessionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ValidateSession_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ValidateSessionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ValidateSessionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ValidateSessionResult(%+v)", *p)
}

type QueryUserBasicInfoByUIDArgs struct {
	Uid int64 `thrift:"uid,1,required" json:"uid"`
}

func NewQueryUserBasicInfoByUIDArgs() *QueryUserBasicInfoByUIDArgs {
	return &QueryUserBasicInfoByUIDArgs{}
}

func (p *QueryUserBasicInfoByUIDArgs) GetUid() int64 {
	return p.Uid
}
func (p *QueryUserBasicInfoByUIDArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *QueryUserBasicInfoByUIDArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Uid = v
	}
	return nil
}

func (p *QueryUserBasicInfoByUIDArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("QueryUserBasicInfoByUID_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *QueryUserBasicInfoByUIDArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("uid", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:uid: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Uid)); err != nil {
		return fmt.Errorf("%T.uid (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:uid: %s", p, err)
	}
	return err
}

func (p *QueryUserBasicInfoByUIDArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("QueryUserBasicInfoByUIDArgs(%+v)", *p)
}

type QueryUserBasicInfoByUIDResult struct {
	Success *UserBasicInfo `thrift:"success,0" json:"success"`
}

func NewQueryUserBasicInfoByUIDResult() *QueryUserBasicInfoByUIDResult {
	return &QueryUserBasicInfoByUIDResult{}
}

var QueryUserBasicInfoByUIDResult_Success_DEFAULT *UserBasicInfo

func (p *QueryUserBasicInfoByUIDResult) GetSuccess() *UserBasicInfo {
	if !p.IsSetSuccess() {
		return QueryUserBasicInfoByUIDResult_Success_DEFAULT
	}
	return p.Success
}
func (p *QueryUserBasicInfoByUIDResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *QueryUserBasicInfoByUIDResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *QueryUserBasicInfoByUIDResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &UserBasicInfo{
		MUid: -1,

		MGender: -1,
	}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *QueryUserBasicInfoByUIDResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("QueryUserBasicInfoByUID_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *QueryUserBasicInfoByUIDResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *QueryUserBasicInfoByUIDResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("QueryUserBasicInfoByUIDResult(%+v)", *p)
}

type BatchQueryUserBasicInfoArgs struct {
	Uids []int64 `thrift:"uids,1,required" json:"uids"`
}

func NewBatchQueryUserBasicInfoArgs() *BatchQueryUserBasicInfoArgs {
	return &BatchQueryUserBasicInfoArgs{}
}

func (p *BatchQueryUserBasicInfoArgs) GetUids() []int64 {
	return p.Uids
}
func (p *BatchQueryUserBasicInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BatchQueryUserBasicInfoArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]int64, 0, size)
	p.Uids = tSlice
	for i := 0; i < size; i++ {
		var _elem44 int64
		if v, err := iprot.ReadI64(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem44 = v
		}
		p.Uids = append(p.Uids, _elem44)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *BatchQueryUserBasicInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("BatchQueryUserBasicInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *BatchQueryUserBasicInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("uids", thrift.LIST, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:uids: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.I64, len(p.Uids)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Uids {
		if err := oprot.WriteI64(int64(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:uids: %s", p, err)
	}
	return err
}

func (p *BatchQueryUserBasicInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BatchQueryUserBasicInfoArgs(%+v)", *p)
}

type BatchQueryUserBasicInfoResult struct {
	Success []*UserBasicInfo `thrift:"success,0" json:"success"`
}

func NewBatchQueryUserBasicInfoResult() *BatchQueryUserBasicInfoResult {
	return &BatchQueryUserBasicInfoResult{}
}

var BatchQueryUserBasicInfoResult_Success_DEFAULT []*UserBasicInfo

func (p *BatchQueryUserBasicInfoResult) GetSuccess() []*UserBasicInfo {
	return p.Success
}
func (p *BatchQueryUserBasicInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *BatchQueryUserBasicInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BatchQueryUserBasicInfoResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*UserBasicInfo, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem45 := &UserBasicInfo{
			MUid: -1,

			MGender: -1,
		}
		if err := _elem45.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem45, err)
		}
		p.Success = append(p.Success, _elem45)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *BatchQueryUserBasicInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("BatchQueryUserBasicInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *BatchQueryUserBasicInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *BatchQueryUserBasicInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BatchQueryUserBasicInfoResult(%+v)", *p)
}

type QueryUserRegAffliatedInfoByUIDArgs struct {
	Uid int64 `thrift:"uid,1,required" json:"uid"`
}

func NewQueryUserRegAffliatedInfoByUIDArgs() *QueryUserRegAffliatedInfoByUIDArgs {
	return &QueryUserRegAffliatedInfoByUIDArgs{}
}

func (p *QueryUserRegAffliatedInfoByUIDArgs) GetUid() int64 {
	return p.Uid
}
func (p *QueryUserRegAffliatedInfoByUIDArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *QueryUserRegAffliatedInfoByUIDArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Uid = v
	}
	return nil
}

func (p *QueryUserRegAffliatedInfoByUIDArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("QueryUserRegAffliatedInfoByUID_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *QueryUserRegAffliatedInfoByUIDArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("uid", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:uid: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Uid)); err != nil {
		return fmt.Errorf("%T.uid (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:uid: %s", p, err)
	}
	return err
}

func (p *QueryUserRegAffliatedInfoByUIDArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("QueryUserRegAffliatedInfoByUIDArgs(%+v)", *p)
}

type QueryUserRegAffliatedInfoByUIDResult struct {
	Success *RegistrationAffliatedInfo `thrift:"success,0" json:"success"`
}

func NewQueryUserRegAffliatedInfoByUIDResult() *QueryUserRegAffliatedInfoByUIDResult {
	return &QueryUserRegAffliatedInfoByUIDResult{}
}

var QueryUserRegAffliatedInfoByUIDResult_Success_DEFAULT *RegistrationAffliatedInfo

func (p *QueryUserRegAffliatedInfoByUIDResult) GetSuccess() *RegistrationAffliatedInfo {
	if !p.IsSetSuccess() {
		return QueryUserRegAffliatedInfoByUIDResult_Success_DEFAULT
	}
	return p.Success
}
func (p *QueryUserRegAffliatedInfoByUIDResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *QueryUserRegAffliatedInfoByUIDResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *QueryUserRegAffliatedInfoByUIDResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &RegistrationAffliatedInfo{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *QueryUserRegAffliatedInfoByUIDResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("QueryUserRegAffliatedInfoByUID_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *QueryUserRegAffliatedInfoByUIDResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *QueryUserRegAffliatedInfoByUIDResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("QueryUserRegAffliatedInfoByUIDResult(%+v)", *p)
}

type MT4AuthenticationArgs struct {
	LoginInfo *MT4LoginInfo `thrift:"login_info,1,required" json:"login_info"`
}

func NewMT4AuthenticationArgs() *MT4AuthenticationArgs {
	return &MT4AuthenticationArgs{}
}

var MT4AuthenticationArgs_LoginInfo_DEFAULT *MT4LoginInfo

func (p *MT4AuthenticationArgs) GetLoginInfo() *MT4LoginInfo {
	if !p.IsSetLoginInfo() {
		return MT4AuthenticationArgs_LoginInfo_DEFAULT
	}
	return p.LoginInfo
}
func (p *MT4AuthenticationArgs) IsSetLoginInfo() bool {
	return p.LoginInfo != nil
}

func (p *MT4AuthenticationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MT4AuthenticationArgs) ReadField1(iprot thrift.TProtocol) error {
	p.LoginInfo = &MT4LoginInfo{
		MMt4LiveId: -1,

		MUid: -1,
	}
	if err := p.LoginInfo.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.LoginInfo, err)
	}
	return nil
}

func (p *MT4AuthenticationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MT4Authentication_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MT4AuthenticationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("login_info", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:login_info: %s", p, err)
	}
	if err := p.LoginInfo.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.LoginInfo, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:login_info: %s", p, err)
	}
	return err
}

func (p *MT4AuthenticationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MT4AuthenticationArgs(%+v)", *p)
}

type MT4AuthenticationResult struct {
	Success *Errno `thrift:"success,0" json:"success"`
}

func NewMT4AuthenticationResult() *MT4AuthenticationResult {
	return &MT4AuthenticationResult{}
}

var MT4AuthenticationResult_Success_DEFAULT Errno

func (p *MT4AuthenticationResult) GetSuccess() Errno {
	if !p.IsSetSuccess() {
		return MT4AuthenticationResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *MT4AuthenticationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *MT4AuthenticationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MT4AuthenticationResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Errno(v)
		p.Success = &temp
	}
	return nil
}

func (p *MT4AuthenticationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MT4Authentication_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MT4AuthenticationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *MT4AuthenticationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MT4AuthenticationResult(%+v)", *p)
}

type MT4BindAccountArgs struct {
	BindInfo *MT4BindInfo `thrift:"bind_info,1,required" json:"bind_info"`
}

func NewMT4BindAccountArgs() *MT4BindAccountArgs {
	return &MT4BindAccountArgs{}
}

var MT4BindAccountArgs_BindInfo_DEFAULT *MT4BindInfo

func (p *MT4BindAccountArgs) GetBindInfo() *MT4BindInfo {
	if !p.IsSetBindInfo() {
		return MT4BindAccountArgs_BindInfo_DEFAULT
	}
	return p.BindInfo
}
func (p *MT4BindAccountArgs) IsSetBindInfo() bool {
	return p.BindInfo != nil
}

func (p *MT4BindAccountArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MT4BindAccountArgs) ReadField1(iprot thrift.TProtocol) error {
	p.BindInfo = &MT4BindInfo{
		MUid: -1,
	}
	if err := p.BindInfo.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.BindInfo, err)
	}
	return nil
}

func (p *MT4BindAccountArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MT4BindAccount_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MT4BindAccountArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("bind_info", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:bind_info: %s", p, err)
	}
	if err := p.BindInfo.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.BindInfo, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:bind_info: %s", p, err)
	}
	return err
}

func (p *MT4BindAccountArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MT4BindAccountArgs(%+v)", *p)
}

type MT4BindAccountResult struct {
	Success *Errno `thrift:"success,0" json:"success"`
}

func NewMT4BindAccountResult() *MT4BindAccountResult {
	return &MT4BindAccountResult{}
}

var MT4BindAccountResult_Success_DEFAULT Errno

func (p *MT4BindAccountResult) GetSuccess() Errno {
	if !p.IsSetSuccess() {
		return MT4BindAccountResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *MT4BindAccountResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *MT4BindAccountResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MT4BindAccountResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Errno(v)
		p.Success = &temp
	}
	return nil
}

func (p *MT4BindAccountResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MT4BindAccount_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MT4BindAccountResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *MT4BindAccountResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MT4BindAccountResult(%+v)", *p)
}

type MT4QueryBindInfoArgs struct {
	Uid int64 `thrift:"uid,1,required" json:"uid"`
}

func NewMT4QueryBindInfoArgs() *MT4QueryBindInfoArgs {
	return &MT4QueryBindInfoArgs{}
}

func (p *MT4QueryBindInfoArgs) GetUid() int64 {
	return p.Uid
}
func (p *MT4QueryBindInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MT4QueryBindInfoArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Uid = v
	}
	return nil
}

func (p *MT4QueryBindInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MT4QueryBindInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MT4QueryBindInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("uid", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:uid: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Uid)); err != nil {
		return fmt.Errorf("%T.uid (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:uid: %s", p, err)
	}
	return err
}

func (p *MT4QueryBindInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MT4QueryBindInfoArgs(%+v)", *p)
}

type MT4QueryBindInfoResult struct {
	Success *MT4Info `thrift:"success,0" json:"success"`
}

func NewMT4QueryBindInfoResult() *MT4QueryBindInfoResult {
	return &MT4QueryBindInfoResult{}
}

var MT4QueryBindInfoResult_Success_DEFAULT *MT4Info

func (p *MT4QueryBindInfoResult) GetSuccess() *MT4Info {
	if !p.IsSetSuccess() {
		return MT4QueryBindInfoResult_Success_DEFAULT
	}
	return p.Success
}
func (p *MT4QueryBindInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *MT4QueryBindInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MT4QueryBindInfoResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &MT4Info{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *MT4QueryBindInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MT4QueryBindInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MT4QueryBindInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *MT4QueryBindInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MT4QueryBindInfoResult(%+v)", *p)
}

type ForbagAuthenticationArgs struct {
	LoginInfo *ForbagLoginInfo `thrift:"login_info,1,required" json:"login_info"`
}

func NewForbagAuthenticationArgs() *ForbagAuthenticationArgs {
	return &ForbagAuthenticationArgs{}
}

var ForbagAuthenticationArgs_LoginInfo_DEFAULT *ForbagLoginInfo

func (p *ForbagAuthenticationArgs) GetLoginInfo() *ForbagLoginInfo {
	if !p.IsSetLoginInfo() {
		return ForbagAuthenticationArgs_LoginInfo_DEFAULT
	}
	return p.LoginInfo
}
func (p *ForbagAuthenticationArgs) IsSetLoginInfo() bool {
	return p.LoginInfo != nil
}

func (p *ForbagAuthenticationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ForbagAuthenticationArgs) ReadField1(iprot thrift.TProtocol) error {
	p.LoginInfo = &ForbagLoginInfo{
		MUid: -1,
	}
	if err := p.LoginInfo.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.LoginInfo, err)
	}
	return nil
}

func (p *ForbagAuthenticationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ForbagAuthentication_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ForbagAuthenticationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("login_info", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:login_info: %s", p, err)
	}
	if err := p.LoginInfo.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.LoginInfo, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:login_info: %s", p, err)
	}
	return err
}

func (p *ForbagAuthenticationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ForbagAuthenticationArgs(%+v)", *p)
}

type ForbagAuthenticationResult struct {
	Success *Errno `thrift:"success,0" json:"success"`
}

func NewForbagAuthenticationResult() *ForbagAuthenticationResult {
	return &ForbagAuthenticationResult{}
}

var ForbagAuthenticationResult_Success_DEFAULT Errno

func (p *ForbagAuthenticationResult) GetSuccess() Errno {
	if !p.IsSetSuccess() {
		return ForbagAuthenticationResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *ForbagAuthenticationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ForbagAuthenticationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ForbagAuthenticationResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Errno(v)
		p.Success = &temp
	}
	return nil
}

func (p *ForbagAuthenticationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ForbagAuthentication_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ForbagAuthenticationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ForbagAuthenticationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ForbagAuthenticationResult(%+v)", *p)
}

type ForbagBindAccountArgs struct {
	BindInfo *ForbagBindInfo `thrift:"bind_info,1,required" json:"bind_info"`
}

func NewForbagBindAccountArgs() *ForbagBindAccountArgs {
	return &ForbagBindAccountArgs{}
}

var ForbagBindAccountArgs_BindInfo_DEFAULT *ForbagBindInfo

func (p *ForbagBindAccountArgs) GetBindInfo() *ForbagBindInfo {
	if !p.IsSetBindInfo() {
		return ForbagBindAccountArgs_BindInfo_DEFAULT
	}
	return p.BindInfo
}
func (p *ForbagBindAccountArgs) IsSetBindInfo() bool {
	return p.BindInfo != nil
}

func (p *ForbagBindAccountArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ForbagBindAccountArgs) ReadField1(iprot thrift.TProtocol) error {
	p.BindInfo = &ForbagBindInfo{
		MUid: -1,
	}
	if err := p.BindInfo.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.BindInfo, err)
	}
	return nil
}

func (p *ForbagBindAccountArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ForbagBindAccount_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ForbagBindAccountArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("bind_info", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:bind_info: %s", p, err)
	}
	if err := p.BindInfo.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.BindInfo, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:bind_info: %s", p, err)
	}
	return err
}

func (p *ForbagBindAccountArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ForbagBindAccountArgs(%+v)", *p)
}

type ForbagBindAccountResult struct {
	Success *Errno `thrift:"success,0" json:"success"`
}

func NewForbagBindAccountResult() *ForbagBindAccountResult {
	return &ForbagBindAccountResult{}
}

var ForbagBindAccountResult_Success_DEFAULT Errno

func (p *ForbagBindAccountResult) GetSuccess() Errno {
	if !p.IsSetSuccess() {
		return ForbagBindAccountResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *ForbagBindAccountResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ForbagBindAccountResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ForbagBindAccountResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Errno(v)
		p.Success = &temp
	}
	return nil
}

func (p *ForbagBindAccountResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ForbagBindAccount_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ForbagBindAccountResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ForbagBindAccountResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ForbagBindAccountResult(%+v)", *p)
}

type ForbagQueryBrokerInfoByUIDArgs struct {
	Uid int64 `thrift:"uid,1,required" json:"uid"`
}

func NewForbagQueryBrokerInfoByUIDArgs() *ForbagQueryBrokerInfoByUIDArgs {
	return &ForbagQueryBrokerInfoByUIDArgs{}
}

func (p *ForbagQueryBrokerInfoByUIDArgs) GetUid() int64 {
	return p.Uid
}
func (p *ForbagQueryBrokerInfoByUIDArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ForbagQueryBrokerInfoByUIDArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Uid = v
	}
	return nil
}

func (p *ForbagQueryBrokerInfoByUIDArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ForbagQueryBrokerInfoByUID_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ForbagQueryBrokerInfoByUIDArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("uid", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:uid: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Uid)); err != nil {
		return fmt.Errorf("%T.uid (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:uid: %s", p, err)
	}
	return err
}

func (p *ForbagQueryBrokerInfoByUIDArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ForbagQueryBrokerInfoByUIDArgs(%+v)", *p)
}

type ForbagQueryBrokerInfoByUIDResult struct {
	Success []*ForbagBrokerInfo `thrift:"success,0" json:"success"`
}

func NewForbagQueryBrokerInfoByUIDResult() *ForbagQueryBrokerInfoByUIDResult {
	return &ForbagQueryBrokerInfoByUIDResult{}
}

var ForbagQueryBrokerInfoByUIDResult_Success_DEFAULT []*ForbagBrokerInfo

func (p *ForbagQueryBrokerInfoByUIDResult) GetSuccess() []*ForbagBrokerInfo {
	return p.Success
}
func (p *ForbagQueryBrokerInfoByUIDResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ForbagQueryBrokerInfoByUIDResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ForbagQueryBrokerInfoByUIDResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*ForbagBrokerInfo, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem46 := &ForbagBrokerInfo{}
		if err := _elem46.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem46, err)
		}
		p.Success = append(p.Success, _elem46)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ForbagQueryBrokerInfoByUIDResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ForbagQueryBrokerInfoByUID_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ForbagQueryBrokerInfoByUIDResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ForbagQueryBrokerInfoByUIDResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ForbagQueryBrokerInfoByUIDResult(%+v)", *p)
}

type QuickFixAuthenticationArgs struct {
	LoginInfo *QuickFixLoginInfo `thrift:"login_info,1,required" json:"login_info"`
}

func NewQuickFixAuthenticationArgs() *QuickFixAuthenticationArgs {
	return &QuickFixAuthenticationArgs{}
}

var QuickFixAuthenticationArgs_LoginInfo_DEFAULT *QuickFixLoginInfo

func (p *QuickFixAuthenticationArgs) GetLoginInfo() *QuickFixLoginInfo {
	if !p.IsSetLoginInfo() {
		return QuickFixAuthenticationArgs_LoginInfo_DEFAULT
	}
	return p.LoginInfo
}
func (p *QuickFixAuthenticationArgs) IsSetLoginInfo() bool {
	return p.LoginInfo != nil
}

func (p *QuickFixAuthenticationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *QuickFixAuthenticationArgs) ReadField1(iprot thrift.TProtocol) error {
	p.LoginInfo = &QuickFixLoginInfo{
		MUid: -1,
	}
	if err := p.LoginInfo.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.LoginInfo, err)
	}
	return nil
}

func (p *QuickFixAuthenticationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("QuickFixAuthentication_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *QuickFixAuthenticationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("login_info", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:login_info: %s", p, err)
	}
	if err := p.LoginInfo.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.LoginInfo, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:login_info: %s", p, err)
	}
	return err
}

func (p *QuickFixAuthenticationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("QuickFixAuthenticationArgs(%+v)", *p)
}

type QuickFixAuthenticationResult struct {
	Success *Errno `thrift:"success,0" json:"success"`
}

func NewQuickFixAuthenticationResult() *QuickFixAuthenticationResult {
	return &QuickFixAuthenticationResult{}
}

var QuickFixAuthenticationResult_Success_DEFAULT Errno

func (p *QuickFixAuthenticationResult) GetSuccess() Errno {
	if !p.IsSetSuccess() {
		return QuickFixAuthenticationResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *QuickFixAuthenticationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *QuickFixAuthenticationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *QuickFixAuthenticationResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Errno(v)
		p.Success = &temp
	}
	return nil
}

func (p *QuickFixAuthenticationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("QuickFixAuthentication_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *QuickFixAuthenticationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *QuickFixAuthenticationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("QuickFixAuthenticationResult(%+v)", *p)
}

type QuickFixBindAccountArgs struct {
	BindInfo *QuickFixBindInfo `thrift:"bind_info,1,required" json:"bind_info"`
}

func NewQuickFixBindAccountArgs() *QuickFixBindAccountArgs {
	return &QuickFixBindAccountArgs{}
}

var QuickFixBindAccountArgs_BindInfo_DEFAULT *QuickFixBindInfo

func (p *QuickFixBindAccountArgs) GetBindInfo() *QuickFixBindInfo {
	if !p.IsSetBindInfo() {
		return QuickFixBindAccountArgs_BindInfo_DEFAULT
	}
	return p.BindInfo
}
func (p *QuickFixBindAccountArgs) IsSetBindInfo() bool {
	return p.BindInfo != nil
}

func (p *QuickFixBindAccountArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *QuickFixBindAccountArgs) ReadField1(iprot thrift.TProtocol) error {
	p.BindInfo = &QuickFixBindInfo{
		MUid: -1,
	}
	if err := p.BindInfo.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.BindInfo, err)
	}
	return nil
}

func (p *QuickFixBindAccountArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("QuickFixBindAccount_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *QuickFixBindAccountArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("bind_info", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:bind_info: %s", p, err)
	}
	if err := p.BindInfo.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.BindInfo, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:bind_info: %s", p, err)
	}
	return err
}

func (p *QuickFixBindAccountArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("QuickFixBindAccountArgs(%+v)", *p)
}

type QuickFixBindAccountResult struct {
	Success *Errno `thrift:"success,0" json:"success"`
}

func NewQuickFixBindAccountResult() *QuickFixBindAccountResult {
	return &QuickFixBindAccountResult{}
}

var QuickFixBindAccountResult_Success_DEFAULT Errno

func (p *QuickFixBindAccountResult) GetSuccess() Errno {
	if !p.IsSetSuccess() {
		return QuickFixBindAccountResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *QuickFixBindAccountResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *QuickFixBindAccountResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *QuickFixBindAccountResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Errno(v)
		p.Success = &temp
	}
	return nil
}

func (p *QuickFixBindAccountResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("QuickFixBindAccount_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *QuickFixBindAccountResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *QuickFixBindAccountResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("QuickFixBindAccountResult(%+v)", *p)
}

type P2PAuthenticationByArgs struct {
	LoginInfo *P2PLoginInfo `thrift:"login_info,1,required" json:"login_info"`
}

func NewP2PAuthenticationByArgs() *P2PAuthenticationByArgs {
	return &P2PAuthenticationByArgs{}
}

var P2PAuthenticationByArgs_LoginInfo_DEFAULT *P2PLoginInfo

func (p *P2PAuthenticationByArgs) GetLoginInfo() *P2PLoginInfo {
	if !p.IsSetLoginInfo() {
		return P2PAuthenticationByArgs_LoginInfo_DEFAULT
	}
	return p.LoginInfo
}
func (p *P2PAuthenticationByArgs) IsSetLoginInfo() bool {
	return p.LoginInfo != nil
}

func (p *P2PAuthenticationByArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *P2PAuthenticationByArgs) ReadField1(iprot thrift.TProtocol) error {
	p.LoginInfo = &P2PLoginInfo{
		MUid: -1,
	}
	if err := p.LoginInfo.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.LoginInfo, err)
	}
	return nil
}

func (p *P2PAuthenticationByArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("P2PAuthenticationBy_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *P2PAuthenticationByArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("login_info", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:login_info: %s", p, err)
	}
	if err := p.LoginInfo.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.LoginInfo, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:login_info: %s", p, err)
	}
	return err
}

func (p *P2PAuthenticationByArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("P2PAuthenticationByArgs(%+v)", *p)
}

type P2PAuthenticationByResult struct {
	Success *Errno `thrift:"success,0" json:"success"`
}

func NewP2PAuthenticationByResult() *P2PAuthenticationByResult {
	return &P2PAuthenticationByResult{}
}

var P2PAuthenticationByResult_Success_DEFAULT Errno

func (p *P2PAuthenticationByResult) GetSuccess() Errno {
	if !p.IsSetSuccess() {
		return P2PAuthenticationByResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *P2PAuthenticationByResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *P2PAuthenticationByResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *P2PAuthenticationByResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Errno(v)
		p.Success = &temp
	}
	return nil
}

func (p *P2PAuthenticationByResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("P2PAuthenticationBy_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *P2PAuthenticationByResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *P2PAuthenticationByResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("P2PAuthenticationByResult(%+v)", *p)
}

type P2PBindAccountArgs struct {
	BindInfo *P2PBindInfo `thrift:"bind_info,1,required" json:"bind_info"`
}

func NewP2PBindAccountArgs() *P2PBindAccountArgs {
	return &P2PBindAccountArgs{}
}

var P2PBindAccountArgs_BindInfo_DEFAULT *P2PBindInfo

func (p *P2PBindAccountArgs) GetBindInfo() *P2PBindInfo {
	if !p.IsSetBindInfo() {
		return P2PBindAccountArgs_BindInfo_DEFAULT
	}
	return p.BindInfo
}
func (p *P2PBindAccountArgs) IsSetBindInfo() bool {
	return p.BindInfo != nil
}

func (p *P2PBindAccountArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *P2PBindAccountArgs) ReadField1(iprot thrift.TProtocol) error {
	p.BindInfo = &P2PBindInfo{
		MUid: -1,
	}
	if err := p.BindInfo.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.BindInfo, err)
	}
	return nil
}

func (p *P2PBindAccountArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("P2PBindAccount_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *P2PBindAccountArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("bind_info", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:bind_info: %s", p, err)
	}
	if err := p.BindInfo.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.BindInfo, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:bind_info: %s", p, err)
	}
	return err
}

func (p *P2PBindAccountArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("P2PBindAccountArgs(%+v)", *p)
}

type P2PBindAccountResult struct {
	Success *Errno `thrift:"success,0" json:"success"`
}

func NewP2PBindAccountResult() *P2PBindAccountResult {
	return &P2PBindAccountResult{}
}

var P2PBindAccountResult_Success_DEFAULT Errno

func (p *P2PBindAccountResult) GetSuccess() Errno {
	if !p.IsSetSuccess() {
		return P2PBindAccountResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *P2PBindAccountResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *P2PBindAccountResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *P2PBindAccountResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Errno(v)
		p.Success = &temp
	}
	return nil
}

func (p *P2PBindAccountResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("P2PBindAccount_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *P2PBindAccountResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *P2PBindAccountResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("P2PBindAccountResult(%+v)", *p)
}

type P2PQueryBindInfoArgs struct {
	Uid int64 `thrift:"uid,1,required" json:"uid"`
}

func NewP2PQueryBindInfoArgs() *P2PQueryBindInfoArgs {
	return &P2PQueryBindInfoArgs{}
}

func (p *P2PQueryBindInfoArgs) GetUid() int64 {
	return p.Uid
}
func (p *P2PQueryBindInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *P2PQueryBindInfoArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Uid = v
	}
	return nil
}

func (p *P2PQueryBindInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("P2PQueryBindInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *P2PQueryBindInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("uid", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:uid: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Uid)); err != nil {
		return fmt.Errorf("%T.uid (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:uid: %s", p, err)
	}
	return err
}

func (p *P2PQueryBindInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("P2PQueryBindInfoArgs(%+v)", *p)
}

type P2PQueryBindInfoResult struct {
	Success *P2PInfo `thrift:"success,0" json:"success"`
}

func NewP2PQueryBindInfoResult() *P2PQueryBindInfoResult {
	return &P2PQueryBindInfoResult{}
}

var P2PQueryBindInfoResult_Success_DEFAULT *P2PInfo

func (p *P2PQueryBindInfoResult) GetSuccess() *P2PInfo {
	if !p.IsSetSuccess() {
		return P2PQueryBindInfoResult_Success_DEFAULT
	}
	return p.Success
}
func (p *P2PQueryBindInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *P2PQueryBindInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *P2PQueryBindInfoResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &P2PInfo{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *P2PQueryBindInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("P2PQueryBindInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *P2PQueryBindInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *P2PQueryBindInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("P2PQueryBindInfoResult(%+v)", *p)
}

type UpdateUserBasicInfoArgs struct {
	Userinfo *UserBasicInfo `thrift:"userinfo,1,required" json:"userinfo"`
}

func NewUpdateUserBasicInfoArgs() *UpdateUserBasicInfoArgs {
	return &UpdateUserBasicInfoArgs{}
}

var UpdateUserBasicInfoArgs_Userinfo_DEFAULT *UserBasicInfo

func (p *UpdateUserBasicInfoArgs) GetUserinfo() *UserBasicInfo {
	if !p.IsSetUserinfo() {
		return UpdateUserBasicInfoArgs_Userinfo_DEFAULT
	}
	return p.Userinfo
}
func (p *UpdateUserBasicInfoArgs) IsSetUserinfo() bool {
	return p.Userinfo != nil
}

func (p *UpdateUserBasicInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateUserBasicInfoArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Userinfo = &UserBasicInfo{
		MUid: -1,

		MGender: -1,
	}
	if err := p.Userinfo.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Userinfo, err)
	}
	return nil
}

func (p *UpdateUserBasicInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("UpdateUserBasicInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateUserBasicInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("userinfo", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:userinfo: %s", p, err)
	}
	if err := p.Userinfo.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Userinfo, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:userinfo: %s", p, err)
	}
	return err
}

func (p *UpdateUserBasicInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateUserBasicInfoArgs(%+v)", *p)
}

type UpdateUserBasicInfoResult struct {
	Success *Errno `thrift:"success,0" json:"success"`
}

func NewUpdateUserBasicInfoResult() *UpdateUserBasicInfoResult {
	return &UpdateUserBasicInfoResult{}
}

var UpdateUserBasicInfoResult_Success_DEFAULT Errno

func (p *UpdateUserBasicInfoResult) GetSuccess() Errno {
	if !p.IsSetSuccess() {
		return UpdateUserBasicInfoResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *UpdateUserBasicInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateUserBasicInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateUserBasicInfoResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Errno(v)
		p.Success = &temp
	}
	return nil
}

func (p *UpdateUserBasicInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("UpdateUserBasicInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateUserBasicInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *UpdateUserBasicInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateUserBasicInfoResult(%+v)", *p)
}

type ResetUserPasswordByUIDArgs struct {
	Uid        int64  `thrift:"uid,1,required" json:"uid"`
	Oldpasswd  string `thrift:"oldpasswd,2,required" json:"oldpasswd"`
	Newpasswd_ string `thrift:"newpasswd,3,required" json:"newpasswd"`
}

func NewResetUserPasswordByUIDArgs() *ResetUserPasswordByUIDArgs {
	return &ResetUserPasswordByUIDArgs{}
}

func (p *ResetUserPasswordByUIDArgs) GetUid() int64 {
	return p.Uid
}

func (p *ResetUserPasswordByUIDArgs) GetOldpasswd() string {
	return p.Oldpasswd
}

func (p *ResetUserPasswordByUIDArgs) GetNewpasswd_() string {
	return p.Newpasswd_
}
func (p *ResetUserPasswordByUIDArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ResetUserPasswordByUIDArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Uid = v
	}
	return nil
}

func (p *ResetUserPasswordByUIDArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Oldpasswd = v
	}
	return nil
}

func (p *ResetUserPasswordByUIDArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Newpasswd_ = v
	}
	return nil
}

func (p *ResetUserPasswordByUIDArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ResetUserPasswordByUID_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ResetUserPasswordByUIDArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("uid", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:uid: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Uid)); err != nil {
		return fmt.Errorf("%T.uid (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:uid: %s", p, err)
	}
	return err
}

func (p *ResetUserPasswordByUIDArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("oldpasswd", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:oldpasswd: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Oldpasswd)); err != nil {
		return fmt.Errorf("%T.oldpasswd (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:oldpasswd: %s", p, err)
	}
	return err
}

func (p *ResetUserPasswordByUIDArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("newpasswd", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:newpasswd: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Newpasswd_)); err != nil {
		return fmt.Errorf("%T.newpasswd (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:newpasswd: %s", p, err)
	}
	return err
}

func (p *ResetUserPasswordByUIDArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ResetUserPasswordByUIDArgs(%+v)", *p)
}

type ResetUserPasswordByUIDResult struct {
	Success *Errno `thrift:"success,0" json:"success"`
}

func NewResetUserPasswordByUIDResult() *ResetUserPasswordByUIDResult {
	return &ResetUserPasswordByUIDResult{}
}

var ResetUserPasswordByUIDResult_Success_DEFAULT Errno

func (p *ResetUserPasswordByUIDResult) GetSuccess() Errno {
	if !p.IsSetSuccess() {
		return ResetUserPasswordByUIDResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *ResetUserPasswordByUIDResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ResetUserPasswordByUIDResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ResetUserPasswordByUIDResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Errno(v)
		p.Success = &temp
	}
	return nil
}

func (p *ResetUserPasswordByUIDResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ResetUserPasswordByUID_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ResetUserPasswordByUIDResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ResetUserPasswordByUIDResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ResetUserPasswordByUIDResult(%+v)", *p)
}

type PingArgs struct {
}

func NewPingArgs() *PingArgs {
	return &PingArgs{}
}

func (p *PingArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PingArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Ping_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PingArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PingArgs(%+v)", *p)
}

type PingResult struct {
	Success *Errno `thrift:"success,0" json:"success"`
}

func NewPingResult() *PingResult {
	return &PingResult{}
}

var PingResult_Success_DEFAULT Errno

func (p *PingResult) GetSuccess() Errno {
	if !p.IsSetSuccess() {
		return PingResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *PingResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *PingResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PingResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Errno(v)
		p.Success = &temp
	}
	return nil
}

func (p *PingResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Ping_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PingResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *PingResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PingResult(%+v)", *p)
}
